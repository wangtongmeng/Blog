# 小程序开发

## 应用程序级别文件

- app.js
- app.json
- app.wxss
- project.config.json

应用程序级别，没有 wxml，并且文件唯一；页面级别有 wxml

就近原则，页面级别文件会覆盖应用程序级别对应类型文件

project.config.json 小程序自动生成，一般不需要更改，这是项目配置文件；当多人或多台电脑开发时，使用这个文件，可以实现相同设置。

util 文件夹中的 util.js 是工具类文件

目录结构是指建议结构，可自己更改，没有限制

## 小程序的页面级别结构

从 index  到 log 有 返回按钮， log 是 index 的子页面

![页面分级](C:\Users\Administrator\Desktop\Blog\小程序\img\页面分级.png)

一级页面过多，性能方面会影响性能。

**页面能有几级**？建议五级之内。多层级应用场景，如微信支付

层级太多，**体积**会变大，小程序体积目前 < 2M

体积过大，可以使用**分包加载**，框架-分包加载

- 目前小程序分包大小有以下限制：
  - 整个小程序所有分包大小不超过 8M
  - 单个分包/主包大小不能超过 2M

## 新建 welcome 欢迎页面

### 删除文件

删除文件，留下 pages 空文件夹和 project.config.json

### 新建应用级别文件

点击 + 号，新建

- app.js
- app.json
- app.wxss

### 新建页面文件

pages 目录下，新建 welcome 目录，新建 Page（这里由于报错，需要手动添加）

### 第一个页面

#### 配置文件路径

**快速进入开发文档**：开发者工具-开发者文档

进入开发文档后，点击框架-配置，找到 app.json 配置项列表，第一项 pages 就是我们需要配置的页面路径

**数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。**

```json
// app.json
{
  "pages": [
    "pages/welocme/welcome"
  ]
}
```

若没有新建 welcome 相关文件，通过 app.json  中配置 welcome，微信会自动生成目录和文件，可以作为 + 号新建 或 右键新建外的一个新建文件的方式。

#### 配置页面文件

welcome.json 非必须，若有，至少有 `{}`

welcome.js 也不能为空，需要有初始代码，如下：

```js
Page({})
```

#### 写页面

```html
<view>
  <text>hello world</text>
</view>
```

此时，在模拟器中就会显示 `hello world`的了。

若通过 Page 新建，或在 app.json中配置页面新建，都会自动生成初始代码，不需要自己手写。

### rpx

**引入图片**

复制图片不可以直接粘贴到小程序中，需目录右键-硬盘打开，选择目录进行粘贴。

**text 组件 包裹文本的好处**

文档-组件-基础内容-text，查看。如 selectable 属性，表示文本是否可选，这里，除了文本节点以外的其他节点都无法长按选中。	

**rpx**

操作系统中图片尺寸，width 200px height 200px

微信小程序中，模拟器选 iphone 6

- 若使用 rpx，样式为 width:200rpx;height:200rpx;
- 若使用 px，样式为 width:100px;height:100rpx;只有 iphone6 比例是 1:2

```html
<image style="width:200rpx;height:200rpx;" src='/images/avatar.png'></image>
```

详情，文档-框架-WXSS

### 移动设备的分辨率与 rpx

- 为什么模拟器下 ip6 的分辨率是 375 而设计图一般给 750？
- 如何适配不同的机型？

![手机分辨率与rpx](C:\Users\Administrator\Desktop\Blog\小程序\img\手机分辨率与rpx.png)

pt：逻辑分辨率，pt 的大小和屏幕尺寸有关系，简单可理解为长度和视觉单位

px：物理分辨率，和屏幕尺寸没有关系。

Reader：px 与 pt 的倍数关系

PPI（DPI）：px/寸



1个 pt 可以由 1 个 px 构成，也可以有 2个，还可以由 3 个甚至更多组成

iphone6 下 2 个 px 构成一个 pt

rpx 的作用

设计师给的设计图宽度为 750 指的是 物理分辨率。

6s Plus 和 6 给人的显示效果是相同的，因为分辨率超出人眼极限，无法识别而已。

**如何做不同分辨率设备的自适应？**

以 Ip6 的物理像素 750x1334为视觉设计稿进行设计，而在小程序中使用 rpx 为单位

Ip6 下 1px=1rpx=0.5pt

使用 rpx，小程序会自动在不同的分辨率下进行转换，而使用 px 为单位不会

**为什么要用 iphone6的物理分辨率来做设计图？**

- Ip6下 1px=1rpx（换算关系是作者设计的）
- Ip6 plus 下 1px=0.6px

**不是所有的单位都适合用 rpx**

### flex(弹性盒子)快速布局

微信对 flex 布局有良好的支持

### 启动页 app.json 基础配置

公共样式放到应用级别的 wxss

```css
/* app.wxss */
text {
  font-family: MicroSoft Yahei;
  /* 字体默认取的是操作系统的字体，最后字体设置上 */
}
```

全屏背景色修改，包括两部分：

- page背景色修改
- 微信 window 区背景颜色下盖

```css
/* welcome.wxcss */
page {
  background-color: #b3d4db;
}
/* app.json */
{
  ...
  "window": {
    "navigationBarBackgroundColor": "#b3d4db"
  }
}
```

特殊标记在标签中的使用，如 \n

\n 会换行

```html
<text class='user-name'>hello，\n 童梦</text>
```

## 第二个页面：新闻阅读列表

- Swiper 组件
- App.json 里的关于导航栏、标题配置
- Page 页面与应用程序的生命周期
- 数据绑定(核心知识)
- 数据绑定的运算与逻辑
- AppData区域介绍
- 事件与事件对象
- 缓存
- 列表渲染(核心知识)
- Template 模板的使用(核心知识)

### 使用 Swiper 组件构建轮播图

文档-组件-视图容器-swiper

新建 posts 页面，通过更改 app.json 页面配置路径的顺序，显示要编写的页面。

swiper 设置样式技巧，样式设置到 swiper 上，swiper-item 宽高自动设置为100%。

注意，swiper-item 也是容器，里面可以放非常复杂的内容。

```html
<view>
  <swiper style="width:100%;height:500rpx;">
    <swiper-item>
      <image src='/images/wx.png' style="width:100%;height:500rpx;"></image>
    </swiper-item>
    <swiper-item>Content</swiper-item>
    <swiper-item>Content</swiper-item>
  </swiper>
</view>
```

### Swiper 组件属性设置

更多属性参考文档，文档-组件-视图容器-swiper

这里设置了面板指示点、自动切换、切换间隔

```html
<swiper indicator-dots="true" autoplay="true" interval="2000">
```

### 全局配置与页面配置

全局导航栏与页面级导航栏的背景颜色配置

```json
// app.json
{
  ...
  "window": {
    "navigationBarBackgroundColor": "#405f80" // 深蓝色
  }
}
// welcome.json
{
  "navigationBarBackgroundColor": "#b3d4db" // 青蓝色
}
```

json 格式不同，是因为页面规定只能配置 window 部分属性，见文档-框架-配置-页面配置

### 构建新闻列表（上）

写骨架和内容填充，注意横纵布局分割。

推荐使用 flex 布局完成垂直居中等操作

一个页面的硬编码完成

### JS与小程序Page页面生命周期

文档-框架-逻辑层-页面生命周期

也可以自己写数据和函数

```js
// pages/posts/posts.js
Page({

  /**
   * 页面的初始数据
   */
  data: {

  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log('onload')
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    console.log('onready')

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    console.log('onshow')

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {
    console.log('onhide')

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {
    console.log('onunload')

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    console.log('down')
  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    console.log('onbottom')
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
    console.log('share')
  }
})
```

### 数据绑定概念和基础

数据优先的思想

小程序的数据绑定是**单向**数据绑定，页面只能通过事件来更改 js 中的数据

其他框架有**双向**数据绑定

### setData 方法绑定数据

服务端接收数据 通过 setData方法合并到 Data 中

```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    var post_content1 = {
      date: 'Nov 18 2019',
      title: '正是虾肥蟹壮时',
      post_img: '/images/post/crab.png',
      content: '菊黄蟹正肥，品尝秋之味。徐志摩把，“看初花的荻芦”和“到楼外楼吃蟹”，并列为秋天来杭州不能错过的风雅之事；用林妹妹嗯话讲是',
      view_num: '112',
      collect_num: '96',
      author_img: 'images/avatar/1.png'
    }
    this.setData(post_content1)
  },
```

```html
<view class='post-container'>
    <view class='post-author-date'>
      <image class='post-author' src='{{author_img}}'></image>
      <text class='post-date'>{{date}}</text>
    </view>
    <text class='post-title'>{{title}}</text>
    <image class='post-image' src='{{post_img}}'></image>
    <text class='post-content'>{{content}}</text>
    <view class='post-like'>
      <image class='post-like-image' src='../../images/icon/chat.png'></image>
      <text class='post-like-font'>{{collect_num}}</text>
      <image class='post-like-image' src='../../images/icon/chat.png'></image>
      <text class='post-like-font'>{{view_num}}</text>
    </view>
  </view>
```

### 数据绑定的扩展用法

组件属性填写推荐写法

```html
// 此时轮播图是竖直轮播的，因为 'false' 是字符串，vertical 接受布尔值，被判断为真
<swiper vertical='false' indicator-dots="true" autoplay="true" interval="5000">
// 建议写法，加上 {{}}
<swiper vertical='{{false}}' indicator-dots="{{true}}" autoplay="{{true}}" interval="5000">   
```

数据绑定的 {{}} 中 可以进行运算，具体参考文档-框架-视图层-WXML-数据绑定

### 条件渲染与列表渲染

wx:if

```html
<text wx:if="{{text_condition}}" class='post-date'>{{date}}</text>
```

```js
data: {
    text_condition: true
}
```

wx:for

```html
<block wx:for="{{posts_content}}"  wx:for-item="item" wx:for-index="index">
```

默认 不写 item 和 index 属性时，对应 item index

### 小程序的事件机制——捕捉与回调

逻辑：产生事件、捕捉事件、回调函数、处理事件

消除 key warning

```html
  <block wx:key="1" wx:for="{{posts_content}}"  wx:for-item="item" wx:for-index="index">
```

```html
监听 tap 事件
<view class='moto-container' bind:tap="onTap">
```

```js
Page({
  onTap: function () {
    // 有返回箭头
    // wx.navigateTo({
    //   url: '../posts/posts',
    // })

    // 没有箭头
    wx.redirectTo({
      url: '../posts/posts',
    })
  },
  onUnload: function () {
    console.log('welcom page is unload')
  },
  onHide: function () {
    console.log('welcome page is hide')
  }
})
```

navigateTo 有返回箭头，redirectTo 没有返回箭头；这和页面生命周期有关。navigateTo 页面只是被隐藏，可以返回；redirectTo  页面被卸载，所以不能返回。

### 小程序的事件机制——catch 与 bind

bind 冒泡

点击外部元素，触发 onContainerTap；点击内部元素，触发 onSubTap 和 onContainerTap

```html
<view class='moto-container' bind:tap="onContainerTap">
    <text class="moto" bind:tap="onSubTap">开启小程序之旅</text>
  </view>
```

```js
// pages/welocme/welcome.js
Page({
  ...
  onContainerTap: function () {
    console.log('Container Tap')
  },
  onSubTap:function () {
    console.log('Sub Tap')
  }
})
```

阻止冒泡，catch

```html
<view class='moto-container' bind:tap="onContainerTap">
    <text class="moto" catch:tap="onSubTap">开启小程序之旅</text>
</view>
```

## 小程序的模板化与模块化

### 将业务中的数据分离到单独的数据文件中

### 使用require方法加载js模块儿文件

本地数据导出

```js
// /data/posts-data.js
module.exports = {
  postList: local_database
}
```

本地数据导入

```js
// pages/posts/posts.js
var postsData = require('../../data/posts-data.js')

Page({

  ...
  onLoad: function(options) {
   
    this.setData({
      posts_content: postsData.postList
    })
  }
})
```



断点调试

重新编译，f10下一步

![调试](img\调试.png)

### template模板的使用

创建模板，要有 name 属性

```html
<template name="postItem">
  <view class='post-container'>
    <view class='post-author-date'>
      <image class='post-author' src='{{item.avatar}}'></image>
      <text wx:if="{{item.text_condition}}" class='post-date'>{{item.date}}</text>
    </view>
    <text class='post-title'>{{item.title}}</text>
    <image class='post-image' src='{{item.imgSrc}}'></image>
    <text class='post-content'>{{item.content}}</text>
    <view class='post-like'>
      <image class='post-like-image' src='../../images/icon/chat.png'></image>
      <text class='post-like-font'>{{item.collection}}</text>
      <image class='post-like-image' src='../../images/icon/chat.png'></image>
      <text class='post-like-font'>{{item.reading}}</text>
    </view>
  </view>
</template>
```

使用模板

引入模板，通过 is 属性使用引入的模板

引入路径，可以是绝对路径也可以是相对路径

```html
<!-- 绝对路径 -->
<!-- <import src="/pages/posts/posts-item/posts-item-template.wxml" /> -->
<!-- 相对路径 -->
<import src="posts-item/posts-item-template.wxml" />

<block wx:key="1" wx:for="{{posts_content}}"  wx:for-item="item" wx:for-index="index">
    <!-- template -->
    <template is="postItem"   data="{{item}}" />
</block>
```

引入模板的 wxss

在对应页面的 wxss中，通过 `@import` 引入:

引入路径，可以是绝对路径也可以是相对路径

```css
@import "posts-item/posts-item-template.wxss";
/* @import "/pages/posts/posts-item/posts-item-template.wxss"; */
```

注意： template 只实现了 骨架和样式的模板化，js 不行，所以只是实现了模板化

新版小程序给 js 的解决方案——自定义组件，文档-框架-自定义组件

## 构建新闻详情页面

### 从文章列表跳转到新闻详情页面（组件自定义属性及获取属性）

事件监听不要再 template 上，它只是占位符，渲染后就没有了

通过`data-`属性，传递数据，在页面 js 中 通过 `event.currentTarget.data.set.数据` 获取数据

```html
posts.wxml
<block wx:key="1" wx:for="{{posts_content}}"  wx:for-item="item" wx:for-index="index">
    <!-- template -->
    <view catch:tap="onPostTap" data-postId="{{item.postId}}" data-post-name="name">
        <template is="postItem" data="{{...item}}" />
    </view>
</block>
```

```js
// pages/posts/posts.js
var postsData = require('../../data/posts-data.js')

Page({
  ...
  onPostTap: function (event) {
    // wxml 中 data- 开头数据，只有-开头的字母会大写，其余都会小写
    var postId = event.currentTarget.dataset.postid
    wx.navigateTo({
      url: 'post-detail/post-detail',
    })
  }
})
```

### 先静后动，构建新闻详情页面样式

### 使用数据填充新闻详情页面



```js
// post.js
// 导航传参
onPostTap: function (event) {
    var postId = event.currentTarget.dataset.postid
    wx:navigateTo({
        url: 'post-detail/post-detail?id=' + postId
    })
}
// post-detail.js
// require 获取数据
// options 拿到参数，根据参数拿到对应数据
var postsData = requrie(数据)
Page({
    onLoad: function (options) {
        var postId = options.id
        var postData = postsData.postList[postId]
        this.setData({...postData})
    }
})
```

### 缓存Storage的基本用法

4类操作，8种方法

同步方法，4种

- 设置缓存，wx.setStorageSync()

- 获取缓存，wx.getStorageSync()

- 清除特定缓存，wx.removeStorageSync()

- 清除所有缓存，wxn.clearStorageSync()

异步方法，4种

注意，缓存的上限最大不能超过10MB

###  使用缓存实现文章收藏功能

### 交互反馈 wx.showToast

文档-api-界面-交互

```js
wx.showToast({
      title: postCollected ? '收藏成功':'取消成功',
      duration: 1000,
      icon:'success'
    })
```

loading 不是和用 toats 控制，因为不够精准

### showModal

### 交互反馈wx.showActionSheet

### 同步异步方法对比

### playBackgroundAudio-音乐播放基本实现















## 调试

https://blog.csdn.net/u012411480/article/details/78563104

https://zhuanlan.zhihu.com/p/24835263

























